// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCHEMA_PHRASER_H_
#define FLATBUFFERS_GENERATED_SCHEMA_PHRASER_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace phraser {

struct StoreBlock;

struct Folder;
struct FolderBuilder;

struct FoldersBlock;
struct FoldersBlockBuilder;

struct SymbolSet;
struct SymbolSetBuilder;

struct SymbolSetsBlock;
struct SymbolSetsBlockBuilder;

struct WordTemplate;
struct WordTemplateBuilder;

struct WordTemplateRef;
struct WordTemplateRefBuilder;

struct PhraseTemplate;
struct PhraseTemplateBuilder;

struct PhraseTemplatesBlock;
struct PhraseTemplatesBlockBuilder;

struct Word;
struct WordBuilder;

struct PhraseHistory;
struct PhraseHistoryBuilder;

struct PhraseBlock;
struct PhraseBlockBuilder;

struct KeyBlock;
struct KeyBlockBuilder;

enum BlockType : int8_t {
  BlockType_Unknown = 0,
  BlockType_FoldersBlock = 1,
  BlockType_SymbolSetsBlock = 2,
  BlockType_PhraseTemplatesBlock = 3,
  BlockType_PhraseBlock = 4,
  BlockType_KeyBlock = 5,
  BlockType_MIN = BlockType_Unknown,
  BlockType_MAX = BlockType_KeyBlock
};

inline const BlockType (&EnumValuesBlockType())[6] {
  static const BlockType values[] = {
    BlockType_Unknown,
    BlockType_FoldersBlock,
    BlockType_SymbolSetsBlock,
    BlockType_PhraseTemplatesBlock,
    BlockType_PhraseBlock,
    BlockType_KeyBlock
  };
  return values;
}

inline const char * const *EnumNamesBlockType() {
  static const char * const names[7] = {
    "Unknown",
    "FoldersBlock",
    "SymbolSetsBlock",
    "PhraseTemplatesBlock",
    "PhraseBlock",
    "KeyBlock",
    nullptr
  };
  return names;
}

inline const char *EnumNameBlockType(BlockType e) {
  if (::flatbuffers::IsOutRange(e, BlockType_Unknown, BlockType_KeyBlock)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBlockType()[index];
}

enum Icon : int8_t {
  Icon_Unknown = 0,
  Icon_Key = 1,
  Icon_Login = 2,
  Icon_Asterisk = 3,
  Icon_Lock = 4,
  Icon_Aa = 5,
  Icon_Star = 6,
  Icon_Settings = 7,
  Icon_Folder = 8,
  Icon_ToParentFolder = 9,
  Icon_LookingGlass = 10,
  Icon_LTTriangle = 11,
  Icon_GTTriangle = 12,
  Icon_TextOut = 13,
  Icon_Ledger = 14,
  Icon_PlusMinus = 15,
  Icon_Stars = 16,
  Icon_Message = 17,
  Icon_Quote = 18,
  Icon_Question = 19,
  Icon_Plus = 20,
  Icon_Minus = 21,
  Icon_X = 22,
  Icon_Check = 23,
  Icon_Copy = 24,
  Icon_Download = 25,
  Icon_Upload = 26,
  Icon_MIN = Icon_Unknown,
  Icon_MAX = Icon_Upload
};

inline const Icon (&EnumValuesIcon())[27] {
  static const Icon values[] = {
    Icon_Unknown,
    Icon_Key,
    Icon_Login,
    Icon_Asterisk,
    Icon_Lock,
    Icon_Aa,
    Icon_Star,
    Icon_Settings,
    Icon_Folder,
    Icon_ToParentFolder,
    Icon_LookingGlass,
    Icon_LTTriangle,
    Icon_GTTriangle,
    Icon_TextOut,
    Icon_Ledger,
    Icon_PlusMinus,
    Icon_Stars,
    Icon_Message,
    Icon_Quote,
    Icon_Question,
    Icon_Plus,
    Icon_Minus,
    Icon_X,
    Icon_Check,
    Icon_Copy,
    Icon_Download,
    Icon_Upload
  };
  return values;
}

inline const char * const *EnumNamesIcon() {
  static const char * const names[28] = {
    "Unknown",
    "Key",
    "Login",
    "Asterisk",
    "Lock",
    "Aa",
    "Star",
    "Settings",
    "Folder",
    "ToParentFolder",
    "LookingGlass",
    "LTTriangle",
    "GTTriangle",
    "TextOut",
    "Ledger",
    "PlusMinus",
    "Stars",
    "Message",
    "Quote",
    "Question",
    "Plus",
    "Minus",
    "X",
    "Check",
    "Copy",
    "Download",
    "Upload",
    nullptr
  };
  return names;
}

inline const char *EnumNameIcon(Icon e) {
  if (::flatbuffers::IsOutRange(e, Icon_Unknown, Icon_Upload)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesIcon()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) StoreBlock FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t block_id_;
  int16_t padding0__;
  uint32_t version_;
  uint64_t entropy_;

 public:
  StoreBlock()
      : block_id_(0),
        padding0__(0),
        version_(0),
        entropy_(0) {
    (void)padding0__;
  }
  StoreBlock(uint16_t _block_id, uint32_t _version, uint64_t _entropy)
      : block_id_(::flatbuffers::EndianScalar(_block_id)),
        padding0__(0),
        version_(::flatbuffers::EndianScalar(_version)),
        entropy_(::flatbuffers::EndianScalar(_entropy)) {
    (void)padding0__;
  }
  uint16_t block_id() const {
    return ::flatbuffers::EndianScalar(block_id_);
  }
  void mutate_block_id(uint16_t _block_id) {
    ::flatbuffers::WriteScalar(&block_id_, _block_id);
  }
  uint32_t version() const {
    return ::flatbuffers::EndianScalar(version_);
  }
  void mutate_version(uint32_t _version) {
    ::flatbuffers::WriteScalar(&version_, _version);
  }
  uint64_t entropy() const {
    return ::flatbuffers::EndianScalar(entropy_);
  }
  void mutate_entropy(uint64_t _entropy) {
    ::flatbuffers::WriteScalar(&entropy_, _entropy);
  }
};
FLATBUFFERS_STRUCT_END(StoreBlock, 16);

struct Folder FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FolderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FOLDER_ID = 4,
    VT_PARENT_FOLDER_ID = 6,
    VT_FOLDER_NAME = 8
  };
  uint16_t folder_id() const {
    return GetField<uint16_t>(VT_FOLDER_ID, 0);
  }
  bool mutate_folder_id(uint16_t _folder_id = 0) {
    return SetField<uint16_t>(VT_FOLDER_ID, _folder_id, 0);
  }
  uint16_t parent_folder_id() const {
    return GetField<uint16_t>(VT_PARENT_FOLDER_ID, 0);
  }
  bool mutate_parent_folder_id(uint16_t _parent_folder_id = 0) {
    return SetField<uint16_t>(VT_PARENT_FOLDER_ID, _parent_folder_id, 0);
  }
  const ::flatbuffers::String *folder_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FOLDER_NAME);
  }
  ::flatbuffers::String *mutable_folder_name() {
    return GetPointer<::flatbuffers::String *>(VT_FOLDER_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_FOLDER_ID, 2) &&
           VerifyField<uint16_t>(verifier, VT_PARENT_FOLDER_ID, 2) &&
           VerifyOffset(verifier, VT_FOLDER_NAME) &&
           verifier.VerifyString(folder_name()) &&
           verifier.EndTable();
  }
};

struct FolderBuilder {
  typedef Folder Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_folder_id(uint16_t folder_id) {
    fbb_.AddElement<uint16_t>(Folder::VT_FOLDER_ID, folder_id, 0);
  }
  void add_parent_folder_id(uint16_t parent_folder_id) {
    fbb_.AddElement<uint16_t>(Folder::VT_PARENT_FOLDER_ID, parent_folder_id, 0);
  }
  void add_folder_name(::flatbuffers::Offset<::flatbuffers::String> folder_name) {
    fbb_.AddOffset(Folder::VT_FOLDER_NAME, folder_name);
  }
  explicit FolderBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Folder> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Folder>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Folder> CreateFolder(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t folder_id = 0,
    uint16_t parent_folder_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> folder_name = 0) {
  FolderBuilder builder_(_fbb);
  builder_.add_folder_name(folder_name);
  builder_.add_parent_folder_id(parent_folder_id);
  builder_.add_folder_id(folder_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Folder> CreateFolderDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t folder_id = 0,
    uint16_t parent_folder_id = 0,
    const char *folder_name = nullptr) {
  auto folder_name__ = folder_name ? _fbb.CreateString(folder_name) : 0;
  return phraser::CreateFolder(
      _fbb,
      folder_id,
      parent_folder_id,
      folder_name__);
}

struct FoldersBlock FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FoldersBlockBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCK = 4,
    VT_FOLDERS = 6
  };
  const phraser::StoreBlock *block() const {
    return GetStruct<const phraser::StoreBlock *>(VT_BLOCK);
  }
  phraser::StoreBlock *mutable_block() {
    return GetStruct<phraser::StoreBlock *>(VT_BLOCK);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<phraser::Folder>> *folders() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<phraser::Folder>> *>(VT_FOLDERS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<phraser::Folder>> *mutable_folders() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<phraser::Folder>> *>(VT_FOLDERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<phraser::StoreBlock>(verifier, VT_BLOCK, 8) &&
           VerifyOffset(verifier, VT_FOLDERS) &&
           verifier.VerifyVector(folders()) &&
           verifier.VerifyVectorOfTables(folders()) &&
           verifier.EndTable();
  }
};

struct FoldersBlockBuilder {
  typedef FoldersBlock Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_block(const phraser::StoreBlock *block) {
    fbb_.AddStruct(FoldersBlock::VT_BLOCK, block);
  }
  void add_folders(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<phraser::Folder>>> folders) {
    fbb_.AddOffset(FoldersBlock::VT_FOLDERS, folders);
  }
  explicit FoldersBlockBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FoldersBlock> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FoldersBlock>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FoldersBlock> CreateFoldersBlock(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const phraser::StoreBlock *block = nullptr,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<phraser::Folder>>> folders = 0) {
  FoldersBlockBuilder builder_(_fbb);
  builder_.add_folders(folders);
  builder_.add_block(block);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FoldersBlock> CreateFoldersBlockDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const phraser::StoreBlock *block = nullptr,
    const std::vector<::flatbuffers::Offset<phraser::Folder>> *folders = nullptr) {
  auto folders__ = folders ? _fbb.CreateVector<::flatbuffers::Offset<phraser::Folder>>(*folders) : 0;
  return phraser::CreateFoldersBlock(
      _fbb,
      block,
      folders__);
}

struct SymbolSet FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SymbolSetBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SET_ID = 4,
    VT_SYMBOL_SET_NAME = 6,
    VT_SYMBOL_SET = 8
  };
  uint16_t set_id() const {
    return GetField<uint16_t>(VT_SET_ID, 0);
  }
  bool mutate_set_id(uint16_t _set_id = 0) {
    return SetField<uint16_t>(VT_SET_ID, _set_id, 0);
  }
  const ::flatbuffers::String *symbol_set_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SYMBOL_SET_NAME);
  }
  ::flatbuffers::String *mutable_symbol_set_name() {
    return GetPointer<::flatbuffers::String *>(VT_SYMBOL_SET_NAME);
  }
  const ::flatbuffers::String *symbol_set() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SYMBOL_SET);
  }
  ::flatbuffers::String *mutable_symbol_set() {
    return GetPointer<::flatbuffers::String *>(VT_SYMBOL_SET);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_SET_ID, 2) &&
           VerifyOffset(verifier, VT_SYMBOL_SET_NAME) &&
           verifier.VerifyString(symbol_set_name()) &&
           VerifyOffset(verifier, VT_SYMBOL_SET) &&
           verifier.VerifyString(symbol_set()) &&
           verifier.EndTable();
  }
};

struct SymbolSetBuilder {
  typedef SymbolSet Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_set_id(uint16_t set_id) {
    fbb_.AddElement<uint16_t>(SymbolSet::VT_SET_ID, set_id, 0);
  }
  void add_symbol_set_name(::flatbuffers::Offset<::flatbuffers::String> symbol_set_name) {
    fbb_.AddOffset(SymbolSet::VT_SYMBOL_SET_NAME, symbol_set_name);
  }
  void add_symbol_set(::flatbuffers::Offset<::flatbuffers::String> symbol_set) {
    fbb_.AddOffset(SymbolSet::VT_SYMBOL_SET, symbol_set);
  }
  explicit SymbolSetBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SymbolSet> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SymbolSet>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SymbolSet> CreateSymbolSet(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t set_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> symbol_set_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> symbol_set = 0) {
  SymbolSetBuilder builder_(_fbb);
  builder_.add_symbol_set(symbol_set);
  builder_.add_symbol_set_name(symbol_set_name);
  builder_.add_set_id(set_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SymbolSet> CreateSymbolSetDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t set_id = 0,
    const char *symbol_set_name = nullptr,
    const char *symbol_set = nullptr) {
  auto symbol_set_name__ = symbol_set_name ? _fbb.CreateString(symbol_set_name) : 0;
  auto symbol_set__ = symbol_set ? _fbb.CreateString(symbol_set) : 0;
  return phraser::CreateSymbolSet(
      _fbb,
      set_id,
      symbol_set_name__,
      symbol_set__);
}

struct SymbolSetsBlock FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SymbolSetsBlockBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCK = 4,
    VT_SYMBOL_SETS = 6
  };
  const phraser::StoreBlock *block() const {
    return GetStruct<const phraser::StoreBlock *>(VT_BLOCK);
  }
  phraser::StoreBlock *mutable_block() {
    return GetStruct<phraser::StoreBlock *>(VT_BLOCK);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<phraser::SymbolSet>> *symbol_sets() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<phraser::SymbolSet>> *>(VT_SYMBOL_SETS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<phraser::SymbolSet>> *mutable_symbol_sets() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<phraser::SymbolSet>> *>(VT_SYMBOL_SETS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<phraser::StoreBlock>(verifier, VT_BLOCK, 8) &&
           VerifyOffset(verifier, VT_SYMBOL_SETS) &&
           verifier.VerifyVector(symbol_sets()) &&
           verifier.VerifyVectorOfTables(symbol_sets()) &&
           verifier.EndTable();
  }
};

struct SymbolSetsBlockBuilder {
  typedef SymbolSetsBlock Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_block(const phraser::StoreBlock *block) {
    fbb_.AddStruct(SymbolSetsBlock::VT_BLOCK, block);
  }
  void add_symbol_sets(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<phraser::SymbolSet>>> symbol_sets) {
    fbb_.AddOffset(SymbolSetsBlock::VT_SYMBOL_SETS, symbol_sets);
  }
  explicit SymbolSetsBlockBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SymbolSetsBlock> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SymbolSetsBlock>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SymbolSetsBlock> CreateSymbolSetsBlock(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const phraser::StoreBlock *block = nullptr,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<phraser::SymbolSet>>> symbol_sets = 0) {
  SymbolSetsBlockBuilder builder_(_fbb);
  builder_.add_symbol_sets(symbol_sets);
  builder_.add_block(block);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SymbolSetsBlock> CreateSymbolSetsBlockDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const phraser::StoreBlock *block = nullptr,
    const std::vector<::flatbuffers::Offset<phraser::SymbolSet>> *symbol_sets = nullptr) {
  auto symbol_sets__ = symbol_sets ? _fbb.CreateVector<::flatbuffers::Offset<phraser::SymbolSet>>(*symbol_sets) : 0;
  return phraser::CreateSymbolSetsBlock(
      _fbb,
      block,
      symbol_sets__);
}

struct WordTemplate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WordTemplateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WORD_TEMPLATE_ID = 4,
    VT_PERMISSIONS = 6,
    VT_ICON = 8,
    VT_MIN_LENGTH = 10,
    VT_MAX_LENGTH = 12,
    VT_WORD_TEMPLATE_NAME = 14,
    VT_SYMBOL_SET_IDS = 16
  };
  uint16_t word_template_id() const {
    return GetField<uint16_t>(VT_WORD_TEMPLATE_ID, 0);
  }
  bool mutate_word_template_id(uint16_t _word_template_id = 0) {
    return SetField<uint16_t>(VT_WORD_TEMPLATE_ID, _word_template_id, 0);
  }
  int8_t permissions() const {
    return GetField<int8_t>(VT_PERMISSIONS, 0);
  }
  bool mutate_permissions(int8_t _permissions = 0) {
    return SetField<int8_t>(VT_PERMISSIONS, _permissions, 0);
  }
  phraser::Icon icon() const {
    return static_cast<phraser::Icon>(GetField<int8_t>(VT_ICON, 0));
  }
  bool mutate_icon(phraser::Icon _icon = static_cast<phraser::Icon>(0)) {
    return SetField<int8_t>(VT_ICON, static_cast<int8_t>(_icon), 0);
  }
  uint16_t min_length() const {
    return GetField<uint16_t>(VT_MIN_LENGTH, 0);
  }
  bool mutate_min_length(uint16_t _min_length = 0) {
    return SetField<uint16_t>(VT_MIN_LENGTH, _min_length, 0);
  }
  uint16_t max_length() const {
    return GetField<uint16_t>(VT_MAX_LENGTH, 0);
  }
  bool mutate_max_length(uint16_t _max_length = 0) {
    return SetField<uint16_t>(VT_MAX_LENGTH, _max_length, 0);
  }
  const ::flatbuffers::String *word_template_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_WORD_TEMPLATE_NAME);
  }
  ::flatbuffers::String *mutable_word_template_name() {
    return GetPointer<::flatbuffers::String *>(VT_WORD_TEMPLATE_NAME);
  }
  const ::flatbuffers::Vector<uint16_t> *symbol_set_ids() const {
    return GetPointer<const ::flatbuffers::Vector<uint16_t> *>(VT_SYMBOL_SET_IDS);
  }
  ::flatbuffers::Vector<uint16_t> *mutable_symbol_set_ids() {
    return GetPointer<::flatbuffers::Vector<uint16_t> *>(VT_SYMBOL_SET_IDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_WORD_TEMPLATE_ID, 2) &&
           VerifyField<int8_t>(verifier, VT_PERMISSIONS, 1) &&
           VerifyField<int8_t>(verifier, VT_ICON, 1) &&
           VerifyField<uint16_t>(verifier, VT_MIN_LENGTH, 2) &&
           VerifyField<uint16_t>(verifier, VT_MAX_LENGTH, 2) &&
           VerifyOffset(verifier, VT_WORD_TEMPLATE_NAME) &&
           verifier.VerifyString(word_template_name()) &&
           VerifyOffset(verifier, VT_SYMBOL_SET_IDS) &&
           verifier.VerifyVector(symbol_set_ids()) &&
           verifier.EndTable();
  }
};

struct WordTemplateBuilder {
  typedef WordTemplate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_word_template_id(uint16_t word_template_id) {
    fbb_.AddElement<uint16_t>(WordTemplate::VT_WORD_TEMPLATE_ID, word_template_id, 0);
  }
  void add_permissions(int8_t permissions) {
    fbb_.AddElement<int8_t>(WordTemplate::VT_PERMISSIONS, permissions, 0);
  }
  void add_icon(phraser::Icon icon) {
    fbb_.AddElement<int8_t>(WordTemplate::VT_ICON, static_cast<int8_t>(icon), 0);
  }
  void add_min_length(uint16_t min_length) {
    fbb_.AddElement<uint16_t>(WordTemplate::VT_MIN_LENGTH, min_length, 0);
  }
  void add_max_length(uint16_t max_length) {
    fbb_.AddElement<uint16_t>(WordTemplate::VT_MAX_LENGTH, max_length, 0);
  }
  void add_word_template_name(::flatbuffers::Offset<::flatbuffers::String> word_template_name) {
    fbb_.AddOffset(WordTemplate::VT_WORD_TEMPLATE_NAME, word_template_name);
  }
  void add_symbol_set_ids(::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> symbol_set_ids) {
    fbb_.AddOffset(WordTemplate::VT_SYMBOL_SET_IDS, symbol_set_ids);
  }
  explicit WordTemplateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WordTemplate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WordTemplate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WordTemplate> CreateWordTemplate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t word_template_id = 0,
    int8_t permissions = 0,
    phraser::Icon icon = phraser::Icon_Unknown,
    uint16_t min_length = 0,
    uint16_t max_length = 0,
    ::flatbuffers::Offset<::flatbuffers::String> word_template_name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> symbol_set_ids = 0) {
  WordTemplateBuilder builder_(_fbb);
  builder_.add_symbol_set_ids(symbol_set_ids);
  builder_.add_word_template_name(word_template_name);
  builder_.add_max_length(max_length);
  builder_.add_min_length(min_length);
  builder_.add_word_template_id(word_template_id);
  builder_.add_icon(icon);
  builder_.add_permissions(permissions);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<WordTemplate> CreateWordTemplateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t word_template_id = 0,
    int8_t permissions = 0,
    phraser::Icon icon = phraser::Icon_Unknown,
    uint16_t min_length = 0,
    uint16_t max_length = 0,
    const char *word_template_name = nullptr,
    const std::vector<uint16_t> *symbol_set_ids = nullptr) {
  auto word_template_name__ = word_template_name ? _fbb.CreateString(word_template_name) : 0;
  auto symbol_set_ids__ = symbol_set_ids ? _fbb.CreateVector<uint16_t>(*symbol_set_ids) : 0;
  return phraser::CreateWordTemplate(
      _fbb,
      word_template_id,
      permissions,
      icon,
      min_length,
      max_length,
      word_template_name__,
      symbol_set_ids__);
}

struct WordTemplateRef FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WordTemplateRefBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WORD_TEMPLATE_ID = 4,
    VT_WORD_TEMPLATE_ORDINAL = 6
  };
  uint16_t word_template_id() const {
    return GetField<uint16_t>(VT_WORD_TEMPLATE_ID, 0);
  }
  bool mutate_word_template_id(uint16_t _word_template_id = 0) {
    return SetField<uint16_t>(VT_WORD_TEMPLATE_ID, _word_template_id, 0);
  }
  int8_t word_template_ordinal() const {
    return GetField<int8_t>(VT_WORD_TEMPLATE_ORDINAL, 0);
  }
  bool mutate_word_template_ordinal(int8_t _word_template_ordinal = 0) {
    return SetField<int8_t>(VT_WORD_TEMPLATE_ORDINAL, _word_template_ordinal, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_WORD_TEMPLATE_ID, 2) &&
           VerifyField<int8_t>(verifier, VT_WORD_TEMPLATE_ORDINAL, 1) &&
           verifier.EndTable();
  }
};

struct WordTemplateRefBuilder {
  typedef WordTemplateRef Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_word_template_id(uint16_t word_template_id) {
    fbb_.AddElement<uint16_t>(WordTemplateRef::VT_WORD_TEMPLATE_ID, word_template_id, 0);
  }
  void add_word_template_ordinal(int8_t word_template_ordinal) {
    fbb_.AddElement<int8_t>(WordTemplateRef::VT_WORD_TEMPLATE_ORDINAL, word_template_ordinal, 0);
  }
  explicit WordTemplateRefBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WordTemplateRef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WordTemplateRef>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WordTemplateRef> CreateWordTemplateRef(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t word_template_id = 0,
    int8_t word_template_ordinal = 0) {
  WordTemplateRefBuilder builder_(_fbb);
  builder_.add_word_template_id(word_template_id);
  builder_.add_word_template_ordinal(word_template_ordinal);
  return builder_.Finish();
}

struct PhraseTemplate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PhraseTemplateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PHRASE_TEMPLATE_ID = 4,
    VT_PHRASE_TEMPLATE_NAME = 6,
    VT_WORD_TEMPLATE_REFS = 8
  };
  uint16_t phrase_template_id() const {
    return GetField<uint16_t>(VT_PHRASE_TEMPLATE_ID, 0);
  }
  bool mutate_phrase_template_id(uint16_t _phrase_template_id = 0) {
    return SetField<uint16_t>(VT_PHRASE_TEMPLATE_ID, _phrase_template_id, 0);
  }
  const ::flatbuffers::String *phrase_template_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PHRASE_TEMPLATE_NAME);
  }
  ::flatbuffers::String *mutable_phrase_template_name() {
    return GetPointer<::flatbuffers::String *>(VT_PHRASE_TEMPLATE_NAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<phraser::WordTemplateRef>> *word_template_refs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<phraser::WordTemplateRef>> *>(VT_WORD_TEMPLATE_REFS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<phraser::WordTemplateRef>> *mutable_word_template_refs() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<phraser::WordTemplateRef>> *>(VT_WORD_TEMPLATE_REFS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_PHRASE_TEMPLATE_ID, 2) &&
           VerifyOffset(verifier, VT_PHRASE_TEMPLATE_NAME) &&
           verifier.VerifyString(phrase_template_name()) &&
           VerifyOffset(verifier, VT_WORD_TEMPLATE_REFS) &&
           verifier.VerifyVector(word_template_refs()) &&
           verifier.VerifyVectorOfTables(word_template_refs()) &&
           verifier.EndTable();
  }
};

struct PhraseTemplateBuilder {
  typedef PhraseTemplate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_phrase_template_id(uint16_t phrase_template_id) {
    fbb_.AddElement<uint16_t>(PhraseTemplate::VT_PHRASE_TEMPLATE_ID, phrase_template_id, 0);
  }
  void add_phrase_template_name(::flatbuffers::Offset<::flatbuffers::String> phrase_template_name) {
    fbb_.AddOffset(PhraseTemplate::VT_PHRASE_TEMPLATE_NAME, phrase_template_name);
  }
  void add_word_template_refs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<phraser::WordTemplateRef>>> word_template_refs) {
    fbb_.AddOffset(PhraseTemplate::VT_WORD_TEMPLATE_REFS, word_template_refs);
  }
  explicit PhraseTemplateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PhraseTemplate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PhraseTemplate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PhraseTemplate> CreatePhraseTemplate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t phrase_template_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> phrase_template_name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<phraser::WordTemplateRef>>> word_template_refs = 0) {
  PhraseTemplateBuilder builder_(_fbb);
  builder_.add_word_template_refs(word_template_refs);
  builder_.add_phrase_template_name(phrase_template_name);
  builder_.add_phrase_template_id(phrase_template_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PhraseTemplate> CreatePhraseTemplateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t phrase_template_id = 0,
    const char *phrase_template_name = nullptr,
    const std::vector<::flatbuffers::Offset<phraser::WordTemplateRef>> *word_template_refs = nullptr) {
  auto phrase_template_name__ = phrase_template_name ? _fbb.CreateString(phrase_template_name) : 0;
  auto word_template_refs__ = word_template_refs ? _fbb.CreateVector<::flatbuffers::Offset<phraser::WordTemplateRef>>(*word_template_refs) : 0;
  return phraser::CreatePhraseTemplate(
      _fbb,
      phrase_template_id,
      phrase_template_name__,
      word_template_refs__);
}

struct PhraseTemplatesBlock FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PhraseTemplatesBlockBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCK = 4,
    VT_PHRASE_TEMPLATES = 6,
    VT_WORD_TEMPLATES = 8
  };
  const phraser::StoreBlock *block() const {
    return GetStruct<const phraser::StoreBlock *>(VT_BLOCK);
  }
  phraser::StoreBlock *mutable_block() {
    return GetStruct<phraser::StoreBlock *>(VT_BLOCK);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<phraser::PhraseTemplate>> *phrase_templates() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<phraser::PhraseTemplate>> *>(VT_PHRASE_TEMPLATES);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<phraser::PhraseTemplate>> *mutable_phrase_templates() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<phraser::PhraseTemplate>> *>(VT_PHRASE_TEMPLATES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<phraser::WordTemplate>> *word_templates() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<phraser::WordTemplate>> *>(VT_WORD_TEMPLATES);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<phraser::WordTemplate>> *mutable_word_templates() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<phraser::WordTemplate>> *>(VT_WORD_TEMPLATES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<phraser::StoreBlock>(verifier, VT_BLOCK, 8) &&
           VerifyOffset(verifier, VT_PHRASE_TEMPLATES) &&
           verifier.VerifyVector(phrase_templates()) &&
           verifier.VerifyVectorOfTables(phrase_templates()) &&
           VerifyOffset(verifier, VT_WORD_TEMPLATES) &&
           verifier.VerifyVector(word_templates()) &&
           verifier.VerifyVectorOfTables(word_templates()) &&
           verifier.EndTable();
  }
};

struct PhraseTemplatesBlockBuilder {
  typedef PhraseTemplatesBlock Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_block(const phraser::StoreBlock *block) {
    fbb_.AddStruct(PhraseTemplatesBlock::VT_BLOCK, block);
  }
  void add_phrase_templates(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<phraser::PhraseTemplate>>> phrase_templates) {
    fbb_.AddOffset(PhraseTemplatesBlock::VT_PHRASE_TEMPLATES, phrase_templates);
  }
  void add_word_templates(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<phraser::WordTemplate>>> word_templates) {
    fbb_.AddOffset(PhraseTemplatesBlock::VT_WORD_TEMPLATES, word_templates);
  }
  explicit PhraseTemplatesBlockBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PhraseTemplatesBlock> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PhraseTemplatesBlock>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PhraseTemplatesBlock> CreatePhraseTemplatesBlock(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const phraser::StoreBlock *block = nullptr,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<phraser::PhraseTemplate>>> phrase_templates = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<phraser::WordTemplate>>> word_templates = 0) {
  PhraseTemplatesBlockBuilder builder_(_fbb);
  builder_.add_word_templates(word_templates);
  builder_.add_phrase_templates(phrase_templates);
  builder_.add_block(block);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PhraseTemplatesBlock> CreatePhraseTemplatesBlockDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const phraser::StoreBlock *block = nullptr,
    const std::vector<::flatbuffers::Offset<phraser::PhraseTemplate>> *phrase_templates = nullptr,
    const std::vector<::flatbuffers::Offset<phraser::WordTemplate>> *word_templates = nullptr) {
  auto phrase_templates__ = phrase_templates ? _fbb.CreateVector<::flatbuffers::Offset<phraser::PhraseTemplate>>(*phrase_templates) : 0;
  auto word_templates__ = word_templates ? _fbb.CreateVector<::flatbuffers::Offset<phraser::WordTemplate>>(*word_templates) : 0;
  return phraser::CreatePhraseTemplatesBlock(
      _fbb,
      block,
      phrase_templates__,
      word_templates__);
}

struct Word FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WordBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WORD_TEMPLATE_ID = 4,
    VT_WORD_TEMPLATE_ORDINAL = 6,
    VT_NAME = 8,
    VT_WORD = 10,
    VT_PERMISSIONS = 12,
    VT_ICON = 14
  };
  uint16_t word_template_id() const {
    return GetField<uint16_t>(VT_WORD_TEMPLATE_ID, 0);
  }
  bool mutate_word_template_id(uint16_t _word_template_id = 0) {
    return SetField<uint16_t>(VT_WORD_TEMPLATE_ID, _word_template_id, 0);
  }
  int8_t word_template_ordinal() const {
    return GetField<int8_t>(VT_WORD_TEMPLATE_ORDINAL, 0);
  }
  bool mutate_word_template_ordinal(int8_t _word_template_ordinal = 0) {
    return SetField<int8_t>(VT_WORD_TEMPLATE_ORDINAL, _word_template_ordinal, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::String *mutable_name() {
    return GetPointer<::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *word() const {
    return GetPointer<const ::flatbuffers::String *>(VT_WORD);
  }
  ::flatbuffers::String *mutable_word() {
    return GetPointer<::flatbuffers::String *>(VT_WORD);
  }
  int8_t permissions() const {
    return GetField<int8_t>(VT_PERMISSIONS, 0);
  }
  bool mutate_permissions(int8_t _permissions = 0) {
    return SetField<int8_t>(VT_PERMISSIONS, _permissions, 0);
  }
  phraser::Icon icon() const {
    return static_cast<phraser::Icon>(GetField<int8_t>(VT_ICON, 0));
  }
  bool mutate_icon(phraser::Icon _icon = static_cast<phraser::Icon>(0)) {
    return SetField<int8_t>(VT_ICON, static_cast<int8_t>(_icon), 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_WORD_TEMPLATE_ID, 2) &&
           VerifyField<int8_t>(verifier, VT_WORD_TEMPLATE_ORDINAL, 1) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_WORD) &&
           verifier.VerifyString(word()) &&
           VerifyField<int8_t>(verifier, VT_PERMISSIONS, 1) &&
           VerifyField<int8_t>(verifier, VT_ICON, 1) &&
           verifier.EndTable();
  }
};

struct WordBuilder {
  typedef Word Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_word_template_id(uint16_t word_template_id) {
    fbb_.AddElement<uint16_t>(Word::VT_WORD_TEMPLATE_ID, word_template_id, 0);
  }
  void add_word_template_ordinal(int8_t word_template_ordinal) {
    fbb_.AddElement<int8_t>(Word::VT_WORD_TEMPLATE_ORDINAL, word_template_ordinal, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Word::VT_NAME, name);
  }
  void add_word(::flatbuffers::Offset<::flatbuffers::String> word) {
    fbb_.AddOffset(Word::VT_WORD, word);
  }
  void add_permissions(int8_t permissions) {
    fbb_.AddElement<int8_t>(Word::VT_PERMISSIONS, permissions, 0);
  }
  void add_icon(phraser::Icon icon) {
    fbb_.AddElement<int8_t>(Word::VT_ICON, static_cast<int8_t>(icon), 0);
  }
  explicit WordBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Word> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Word>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Word> CreateWord(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t word_template_id = 0,
    int8_t word_template_ordinal = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> word = 0,
    int8_t permissions = 0,
    phraser::Icon icon = phraser::Icon_Unknown) {
  WordBuilder builder_(_fbb);
  builder_.add_word(word);
  builder_.add_name(name);
  builder_.add_word_template_id(word_template_id);
  builder_.add_icon(icon);
  builder_.add_permissions(permissions);
  builder_.add_word_template_ordinal(word_template_ordinal);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Word> CreateWordDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t word_template_id = 0,
    int8_t word_template_ordinal = 0,
    const char *name = nullptr,
    const char *word = nullptr,
    int8_t permissions = 0,
    phraser::Icon icon = phraser::Icon_Unknown) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto word__ = word ? _fbb.CreateString(word) : 0;
  return phraser::CreateWord(
      _fbb,
      word_template_id,
      word_template_ordinal,
      name__,
      word__,
      permissions,
      icon);
}

struct PhraseHistory FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PhraseHistoryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PHRASE_TEMPLATE_ID = 4,
    VT_PHRASE = 6
  };
  uint16_t phrase_template_id() const {
    return GetField<uint16_t>(VT_PHRASE_TEMPLATE_ID, 0);
  }
  bool mutate_phrase_template_id(uint16_t _phrase_template_id = 0) {
    return SetField<uint16_t>(VT_PHRASE_TEMPLATE_ID, _phrase_template_id, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<phraser::Word>> *phrase() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<phraser::Word>> *>(VT_PHRASE);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<phraser::Word>> *mutable_phrase() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<phraser::Word>> *>(VT_PHRASE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_PHRASE_TEMPLATE_ID, 2) &&
           VerifyOffset(verifier, VT_PHRASE) &&
           verifier.VerifyVector(phrase()) &&
           verifier.VerifyVectorOfTables(phrase()) &&
           verifier.EndTable();
  }
};

struct PhraseHistoryBuilder {
  typedef PhraseHistory Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_phrase_template_id(uint16_t phrase_template_id) {
    fbb_.AddElement<uint16_t>(PhraseHistory::VT_PHRASE_TEMPLATE_ID, phrase_template_id, 0);
  }
  void add_phrase(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<phraser::Word>>> phrase) {
    fbb_.AddOffset(PhraseHistory::VT_PHRASE, phrase);
  }
  explicit PhraseHistoryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PhraseHistory> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PhraseHistory>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PhraseHistory> CreatePhraseHistory(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t phrase_template_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<phraser::Word>>> phrase = 0) {
  PhraseHistoryBuilder builder_(_fbb);
  builder_.add_phrase(phrase);
  builder_.add_phrase_template_id(phrase_template_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PhraseHistory> CreatePhraseHistoryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t phrase_template_id = 0,
    const std::vector<::flatbuffers::Offset<phraser::Word>> *phrase = nullptr) {
  auto phrase__ = phrase ? _fbb.CreateVector<::flatbuffers::Offset<phraser::Word>>(*phrase) : 0;
  return phraser::CreatePhraseHistory(
      _fbb,
      phrase_template_id,
      phrase__);
}

struct PhraseBlock FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PhraseBlockBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCK = 4,
    VT_PHRASE_TEMPLATE_ID = 6,
    VT_FOLDER_ID = 8,
    VT_IS_TOMBSTONE = 10,
    VT_PHRASE_NAME = 12,
    VT_HISTORY = 14
  };
  const phraser::StoreBlock *block() const {
    return GetStruct<const phraser::StoreBlock *>(VT_BLOCK);
  }
  phraser::StoreBlock *mutable_block() {
    return GetStruct<phraser::StoreBlock *>(VT_BLOCK);
  }
  uint16_t phrase_template_id() const {
    return GetField<uint16_t>(VT_PHRASE_TEMPLATE_ID, 0);
  }
  bool mutate_phrase_template_id(uint16_t _phrase_template_id = 0) {
    return SetField<uint16_t>(VT_PHRASE_TEMPLATE_ID, _phrase_template_id, 0);
  }
  uint16_t folder_id() const {
    return GetField<uint16_t>(VT_FOLDER_ID, 0);
  }
  bool mutate_folder_id(uint16_t _folder_id = 0) {
    return SetField<uint16_t>(VT_FOLDER_ID, _folder_id, 0);
  }
  bool is_tombstone() const {
    return GetField<uint8_t>(VT_IS_TOMBSTONE, 0) != 0;
  }
  bool mutate_is_tombstone(bool _is_tombstone = 0) {
    return SetField<uint8_t>(VT_IS_TOMBSTONE, static_cast<uint8_t>(_is_tombstone), 0);
  }
  const ::flatbuffers::String *phrase_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PHRASE_NAME);
  }
  ::flatbuffers::String *mutable_phrase_name() {
    return GetPointer<::flatbuffers::String *>(VT_PHRASE_NAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<phraser::PhraseHistory>> *history() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<phraser::PhraseHistory>> *>(VT_HISTORY);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<phraser::PhraseHistory>> *mutable_history() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<phraser::PhraseHistory>> *>(VT_HISTORY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<phraser::StoreBlock>(verifier, VT_BLOCK, 8) &&
           VerifyField<uint16_t>(verifier, VT_PHRASE_TEMPLATE_ID, 2) &&
           VerifyField<uint16_t>(verifier, VT_FOLDER_ID, 2) &&
           VerifyField<uint8_t>(verifier, VT_IS_TOMBSTONE, 1) &&
           VerifyOffset(verifier, VT_PHRASE_NAME) &&
           verifier.VerifyString(phrase_name()) &&
           VerifyOffset(verifier, VT_HISTORY) &&
           verifier.VerifyVector(history()) &&
           verifier.VerifyVectorOfTables(history()) &&
           verifier.EndTable();
  }
};

struct PhraseBlockBuilder {
  typedef PhraseBlock Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_block(const phraser::StoreBlock *block) {
    fbb_.AddStruct(PhraseBlock::VT_BLOCK, block);
  }
  void add_phrase_template_id(uint16_t phrase_template_id) {
    fbb_.AddElement<uint16_t>(PhraseBlock::VT_PHRASE_TEMPLATE_ID, phrase_template_id, 0);
  }
  void add_folder_id(uint16_t folder_id) {
    fbb_.AddElement<uint16_t>(PhraseBlock::VT_FOLDER_ID, folder_id, 0);
  }
  void add_is_tombstone(bool is_tombstone) {
    fbb_.AddElement<uint8_t>(PhraseBlock::VT_IS_TOMBSTONE, static_cast<uint8_t>(is_tombstone), 0);
  }
  void add_phrase_name(::flatbuffers::Offset<::flatbuffers::String> phrase_name) {
    fbb_.AddOffset(PhraseBlock::VT_PHRASE_NAME, phrase_name);
  }
  void add_history(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<phraser::PhraseHistory>>> history) {
    fbb_.AddOffset(PhraseBlock::VT_HISTORY, history);
  }
  explicit PhraseBlockBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PhraseBlock> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PhraseBlock>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PhraseBlock> CreatePhraseBlock(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const phraser::StoreBlock *block = nullptr,
    uint16_t phrase_template_id = 0,
    uint16_t folder_id = 0,
    bool is_tombstone = false,
    ::flatbuffers::Offset<::flatbuffers::String> phrase_name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<phraser::PhraseHistory>>> history = 0) {
  PhraseBlockBuilder builder_(_fbb);
  builder_.add_history(history);
  builder_.add_phrase_name(phrase_name);
  builder_.add_block(block);
  builder_.add_folder_id(folder_id);
  builder_.add_phrase_template_id(phrase_template_id);
  builder_.add_is_tombstone(is_tombstone);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PhraseBlock> CreatePhraseBlockDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const phraser::StoreBlock *block = nullptr,
    uint16_t phrase_template_id = 0,
    uint16_t folder_id = 0,
    bool is_tombstone = false,
    const char *phrase_name = nullptr,
    const std::vector<::flatbuffers::Offset<phraser::PhraseHistory>> *history = nullptr) {
  auto phrase_name__ = phrase_name ? _fbb.CreateString(phrase_name) : 0;
  auto history__ = history ? _fbb.CreateVector<::flatbuffers::Offset<phraser::PhraseHistory>>(*history) : 0;
  return phraser::CreatePhraseBlock(
      _fbb,
      block,
      phrase_template_id,
      folder_id,
      is_tombstone,
      phrase_name__,
      history__);
}

struct KeyBlock FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KeyBlockBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCK = 4,
    VT_KEY = 6,
    VT_DB_NAME = 8,
    VT_IV = 10,
    VT_BLOCK_COUNT = 12
  };
  const phraser::StoreBlock *block() const {
    return GetStruct<const phraser::StoreBlock *>(VT_BLOCK);
  }
  phraser::StoreBlock *mutable_block() {
    return GetStruct<phraser::StoreBlock *>(VT_BLOCK);
  }
  const ::flatbuffers::Vector<int8_t> *key() const {
    return GetPointer<const ::flatbuffers::Vector<int8_t> *>(VT_KEY);
  }
  ::flatbuffers::Vector<int8_t> *mutable_key() {
    return GetPointer<::flatbuffers::Vector<int8_t> *>(VT_KEY);
  }
  const ::flatbuffers::Vector<int8_t> *db_name() const {
    return GetPointer<const ::flatbuffers::Vector<int8_t> *>(VT_DB_NAME);
  }
  ::flatbuffers::Vector<int8_t> *mutable_db_name() {
    return GetPointer<::flatbuffers::Vector<int8_t> *>(VT_DB_NAME);
  }
  const ::flatbuffers::Vector<int8_t> *iv() const {
    return GetPointer<const ::flatbuffers::Vector<int8_t> *>(VT_IV);
  }
  ::flatbuffers::Vector<int8_t> *mutable_iv() {
    return GetPointer<::flatbuffers::Vector<int8_t> *>(VT_IV);
  }
  uint16_t block_count() const {
    return GetField<uint16_t>(VT_BLOCK_COUNT, 0);
  }
  bool mutate_block_count(uint16_t _block_count = 0) {
    return SetField<uint16_t>(VT_BLOCK_COUNT, _block_count, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<phraser::StoreBlock>(verifier, VT_BLOCK, 8) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyVector(key()) &&
           VerifyOffset(verifier, VT_DB_NAME) &&
           verifier.VerifyVector(db_name()) &&
           VerifyOffset(verifier, VT_IV) &&
           verifier.VerifyVector(iv()) &&
           VerifyField<uint16_t>(verifier, VT_BLOCK_COUNT, 2) &&
           verifier.EndTable();
  }
};

struct KeyBlockBuilder {
  typedef KeyBlock Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_block(const phraser::StoreBlock *block) {
    fbb_.AddStruct(KeyBlock::VT_BLOCK, block);
  }
  void add_key(::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> key) {
    fbb_.AddOffset(KeyBlock::VT_KEY, key);
  }
  void add_db_name(::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> db_name) {
    fbb_.AddOffset(KeyBlock::VT_DB_NAME, db_name);
  }
  void add_iv(::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> iv) {
    fbb_.AddOffset(KeyBlock::VT_IV, iv);
  }
  void add_block_count(uint16_t block_count) {
    fbb_.AddElement<uint16_t>(KeyBlock::VT_BLOCK_COUNT, block_count, 0);
  }
  explicit KeyBlockBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KeyBlock> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KeyBlock>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<KeyBlock> CreateKeyBlock(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const phraser::StoreBlock *block = nullptr,
    ::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> key = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> db_name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> iv = 0,
    uint16_t block_count = 0) {
  KeyBlockBuilder builder_(_fbb);
  builder_.add_iv(iv);
  builder_.add_db_name(db_name);
  builder_.add_key(key);
  builder_.add_block(block);
  builder_.add_block_count(block_count);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<KeyBlock> CreateKeyBlockDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const phraser::StoreBlock *block = nullptr,
    const std::vector<int8_t> *key = nullptr,
    const std::vector<int8_t> *db_name = nullptr,
    const std::vector<int8_t> *iv = nullptr,
    uint16_t block_count = 0) {
  auto key__ = key ? _fbb.CreateVector<int8_t>(*key) : 0;
  auto db_name__ = db_name ? _fbb.CreateVector<int8_t>(*db_name) : 0;
  auto iv__ = iv ? _fbb.CreateVector<int8_t>(*iv) : 0;
  return phraser::CreateKeyBlock(
      _fbb,
      block,
      key__,
      db_name__,
      iv__,
      block_count);
}

}  // namespace phraser

#endif  // FLATBUFFERS_GENERATED_SCHEMA_PHRASER_H_
